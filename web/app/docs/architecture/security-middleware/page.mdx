# Security Middleware Architecture

**TL;DR:** AgentMarket implements defense-in-depth security with layered middleware: Helmet security headers, CORS, rate limiting (5 tiers), input sanitization, CSRF protection, request logging, and comprehensive audit trails - protecting against common web vulnerabilities and abuse.

## Overview

The security middleware stack provides multiple layers of protection for the API server, preventing attacks like XSS, CSRF, command injection, DDoS, and data exfiltration.

```
┌──────────────────────────────────────────────────────────┐
│                    Incoming Request                       │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 1: Security Headers (Helmet)                        │
│  - Content-Security-Policy                                │
│  - X-Frame-Options: DENY                                  │
│  - X-Content-Type-Options: nosniff                        │
│  - Strict-Transport-Security                              │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 2: CORS (Cross-Origin Resource Sharing)            │
│  - Validate origin against whitelist                      │
│  - Allow credentials: true                                │
│  - Expose specific headers only                           │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 3: Rate Limiting (5-tier system)                   │
│  - Global API: 100 req / 15min                            │
│  - Write ops: 20 req / 15min                              │
│  - Registration: 5 req / hour                             │
│  - MCP connections: 10 conn / 15min                       │
│  - MCP messages: 60 msg / min                             │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 4: Request Processing                               │
│  - Request ID generation                                  │
│  - Request size validation (max 1MB)                      │
│  - JSON parsing with limits                               │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 5: Input Sanitization                               │
│  - Trim whitespace                                        │
│  - Remove null bytes                                      │
│  - Recursive object sanitization                          │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 6: CSRF Protection (Production only)                │
│  - Double-submit cookie pattern                           │
│  - Constant-time comparison                               │
│  - Logged security events                                 │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│  Layer 7: Request Logging & Audit Trail                   │
│  - Log all requests with duration                         │
│  - Track IP, User-Agent, Request ID                       │
│  - Store in audit_logs table                              │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────┐
│              Route Handler (Business Logic)                │
└────────────────────────────────────────────────────────────┘
```

<Callout type="warning">
**Security by Design**: Every request passes through ALL middleware layers. A breach in one layer is caught by subsequent layers (defense in depth).
</Callout>

## Middleware Stack

### 1. Helmet (Security Headers)

Helmet sets secure HTTP headers to prevent common vulnerabilities.

```typescript
import helmet from 'helmet';

export const helmetConfig = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", 'ws:', 'wss:'],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false,  // Allows WebSocket embedding
  crossOriginResourcePolicy: { policy: 'cross-origin' },
});

// Apply in Express
app.use(helmetConfig);
```

**Headers Set**:

| Header | Value | Protection Against |
|--------|-------|-------------------|
| **Content-Security-Policy** | `default-src 'self'; ...` | XSS, data injection |
| **X-Frame-Options** | `DENY` | Clickjacking |
| **X-Content-Type-Options** | `nosniff` | MIME type sniffing |
| **Strict-Transport-Security** | `max-age=15552000` | Protocol downgrade |
| **X-Download-Options** | `noopen` | Drive-by downloads |
| **X-Permitted-Cross-Domain-Policies** | `none` | Cross-domain policy files |

**CSP Directives Explained**:
- `defaultSrc: ["'self'"]` - Only load resources from same origin
- `styleSrc: ["'self'", "'unsafe-inline'"]` - Allow inline styles (for dynamic UI)
- `scriptSrc: ["'self'"]` - Only execute scripts from same origin
- `imgSrc: ["'self'", 'data:', 'https:']` - Images from same origin, data URLs, or HTTPS
- `connectSrc: ["'self'", 'ws:', 'wss:']` - Allow WebSocket connections
- `objectSrc: ["'none'"]` - Block Flash, Java, etc.
- `frameSrc: ["'none'"]` - Prevent embedding in iframes

### 2. CORS (Cross-Origin Resource Sharing)

CORS controls which origins can access the API.

```typescript
export const corsOptions = {
  origin: function (
    origin: string | undefined,
    callback: (err: Error | null, allow?: boolean) => void
  ) {
    // Allow requests with no origin (mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);

    // Allowed origins (configure based on environment)
    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:3001',
      'http://localhost:3002',
      'http://127.0.0.1:3000',
      ...(process.env.ALLOWED_ORIGINS?.split(',') || []),
    ];

    if (
      allowedOrigins.indexOf(origin) !== -1 ||
      process.env.NODE_ENV === 'development'
    ) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,                    // Allow cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Payment',
    'X-Request-ID',
    'X-CSRF-Token',
  ],
  exposedHeaders: ['X-CSRF-Token'],
  maxAge: 86400,                        // Cache preflight for 24 hours
};

// Apply in Express
app.use(cors(corsOptions));
```

**Environment-Specific Configuration**:

```bash
# Development (.env.local)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001
NODE_ENV=development

# Production (Railway)
ALLOWED_ORIGINS=https://sentientexchange.com,https://app.sentientexchange.com
NODE_ENV=production
```

**CORS Flow**:

```
┌─────────────────────────────────────────────────────────┐
│ 1. Browser sends preflight request (OPTIONS)            │
│    Origin: https://example.com                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 2. Server checks origin against whitelist               │
│    - If allowed → 200 OK with CORS headers              │
│    - If blocked → Error: Not allowed by CORS            │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 3. Browser sends actual request                         │
│    - Includes cookies if credentials: true              │
└─────────────────────────────────────────────────────────┘
```

### 3. Rate Limiting (5-Tier System)

Multi-tier rate limiting prevents abuse and DDoS attacks.

#### Tier 1: Global API Rate Limit

```typescript
import rateLimitMiddleware from 'express-rate-limit';

export const apiLimiter = rateLimitMiddleware({
  windowMs: 15 * 60 * 1000,           // 15 minutes
  max: 100,                            // Max 100 requests per 15 min per IP
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.',
  },
  standardHeaders: true,               // Return RateLimit-* headers
  legacyHeaders: false,                // Disable X-RateLimit-* headers
  skip: (req) => req.path === '/api/health',  // Skip health checks
});

// Apply to all /api routes
app.use('/api', apiLimiter);
```

**Response Headers**:
```
RateLimit-Limit: 100
RateLimit-Remaining: 85
RateLimit-Reset: 1704994800
```

**429 Response** (when limit exceeded):
```json
{
  "success": false,
  "error": "Too many requests from this IP, please try again later."
}
```

#### Tier 2: Write Operations Limit

```typescript
export const writeLimiter = rateLimitMiddleware({
  windowMs: 15 * 60 * 1000,           // 15 minutes
  max: 20,                             // Max 20 write ops per 15 min
  message: {
    success: false,
    error: 'Too many write operations, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply to POST, PUT, DELETE routes
app.post('/api/services', writeLimiter, async (req, res) => { /* ... */ });
app.put('/api/services/:id', writeLimiter, async (req, res) => { /* ... */ });
app.delete('/api/services/:id', writeLimiter, async (req, res) => { /* ... */ });
```

#### Tier 3: Service Registration Limit

```typescript
export const registrationLimiter = rateLimitMiddleware({
  windowMs: 60 * 60 * 1000,           // 1 hour
  max: 5,                              // Max 5 registrations per hour
  message: {
    success: false,
    error: 'Too many service registrations, please try again in an hour.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply to service registration endpoint
app.post('/api/services', registrationLimiter, async (req, res) => { /* ... */ });
```

#### Tier 4: MCP Connection Limit

```typescript
export const mcpConnectionLimiter = rateLimitMiddleware({
  windowMs: 15 * 60 * 1000,           // 15 minutes
  max: 10,                             // Max 10 new SSE connections per 15 min
  message: {
    success: false,
    error: 'Too many MCP connection attempts, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply to MCP SSE endpoint
app.get('/mcp/sse', mcpConnectionLimiter, async (req, res) => { /* ... */ });
```

#### Tier 5: MCP Message Limit

```typescript
export const mcpMessageLimiter = rateLimitMiddleware({
  windowMs: 1 * 60 * 1000,            // 1 minute
  max: 60,                             // Max 60 messages per minute (1/sec avg)
  message: {
    success: false,
    error: 'Too many MCP messages, please slow down.',
  },
  standardHeaders: true,
  legacyHeaders: false,
  // Extract session ID from query for per-session limiting
  keyGenerator: (req) => {
    const sessionId = req.query.sessionId as string;
    // Use sessionId if available, otherwise use IP
    return sessionId || (req.ip as string) || 'unknown';
  },
});

// Apply to MCP message endpoint
app.post('/mcp/message', mcpMessageLimiter, async (req, res) => { /* ... */ });
```

**Per-Session Limiting**:
- Uses `sessionId` from query parameter as rate limit key
- Prevents single IP from exhausting limits across multiple sessions
- Allows multiple users behind NAT to have independent limits

### 4. Request Processing

#### Request ID Middleware

```typescript
export function requestId(req: Request, res: Response, next: NextFunction) {
  const id =
    (req.headers['x-request-id'] as string) ||
    `${Date.now()}-${Math.random().toString(36).substring(7)}`;

  req.headers['x-request-id'] = id;
  res.setHeader('X-Request-ID', id);
  next();
}

// Apply globally
app.use(requestId);
```

**Benefits**:
- Trace requests across logs
- Debug distributed systems
- Correlate errors with specific requests

**Example**:
```
Request ID: 1704994800-abc123

Logs:
[1704994800-abc123] Incoming request: POST /api/services
[1704994800-abc123] Rate limit check: OK (15/100)
[1704994800-abc123] Validation passed
[1704994800-abc123] Database insert: service-xyz
[1704994800-abc123] Response sent: 201 Created
```

#### Request Size Limiting

```typescript
export function requestSizeLimit(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const contentLength = req.headers['content-length'];

  if (contentLength) {
    const size = parseInt(contentLength, 10);
    const maxSize = 1024 * 1024;      // 1MB

    if (size > maxSize) {
      return res.status(413).json({
        success: false,
        error: 'Request entity too large (max 1MB)',
      });
    }
  }

  next();
}

// Apply globally
app.use(requestSizeLimit);
```

**Protection Against**:
- Large file uploads (DoS)
- Memory exhaustion
- JSON bomb attacks

#### Request Logging

```typescript
export function requestLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  const requestId = req.headers['x-request-id'];

  res.on('finish', () => {
    const duration = Date.now() - start;
    const log = {
      requestId,
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.headers['user-agent'],
    };

    logger.info(JSON.stringify(log));
  });

  next();
}

// Apply globally
app.use(requestLogger);
```

**Log Output**:
```json
{
  "requestId": "1704994800-abc123",
  "method": "POST",
  "path": "/api/services",
  "status": 201,
  "duration": "245ms",
  "ip": "192.168.1.100",
  "userAgent": "Mozilla/5.0 ..."
}
```

### 5. Input Sanitization

Sanitizes all request inputs to prevent injection attacks.

```typescript
export function sanitizeRequest(
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Sanitize query parameters
  if (req.query) {
    Object.keys(req.query).forEach((key) => {
      if (typeof req.query[key] === 'string') {
        req.query[key] = (req.query[key] as string).trim();
      }
    });
  }

  // Sanitize body (basic XSS prevention)
  if (req.body && typeof req.body === 'object') {
    sanitizeObject(req.body);
  }

  next();
}

function sanitizeObject(obj: Record<string, unknown>): void {
  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (typeof value === 'string') {
      // Remove null bytes and trim whitespace
      let sanitized = value.replace(/\0/g, '');
      sanitized = sanitized.trim();
      obj[key] = sanitized;
    } else if (Array.isArray(value)) {
      // Recursively sanitize objects within arrays
      value.forEach((item, index) => {
        if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
          sanitizeObject(value[index] as Record<string, unknown>);
        }
      });
    } else if (
      typeof value === 'object' &&
      value !== null &&
      !Array.isArray(value)
    ) {
      sanitizeObject(value as Record<string, unknown>);
    }
  });
}

// Apply globally
app.use(sanitizeRequest);
```

**Sanitization Actions**:
- Trim leading/trailing whitespace
- Remove null bytes (`\0`)
- Recursive sanitization for nested objects and arrays

**Before Sanitization**:
```json
{
  "name": "  Sentiment Analyzer  \0",
  "description": "  Analyzes sentiment  ",
  "metadata": {
    "tags": ["  ai  ", "  nlp  \0"]
  }
}
```

**After Sanitization**:
```json
{
  "name": "Sentiment Analyzer",
  "description": "Analyzes sentiment",
  "metadata": {
    "tags": ["ai", "nlp"]
  }
}
```

### 6. CSRF Protection

Protects against Cross-Site Request Forgery using double-submit cookie pattern.

#### CSRF Token Generation

```typescript
export function generateCsrfToken(
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Generate a new CSRF token if not present
  if (!req.headers['x-csrf-token']) {
    const token = crypto.randomBytes(32).toString('hex');
    res.setHeader('X-CSRF-Token', token);

    // Store token in a secure cookie (double-submit pattern)
    res.cookie('csrf-token', token, {
      httpOnly: true,                    // Cannot be accessed by JavaScript
      secure: process.env.NODE_ENV === 'production',  // HTTPS only in prod
      sameSite: 'strict',                // Prevent cross-site sending
      maxAge: 3600000,                   // 1 hour
    });
  }
  next();
}

// Apply to routes that need CSRF protection
app.use('/api', generateCsrfToken);
```

#### CSRF Token Validation

```typescript
export function csrfProtection(
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Skip CSRF for read operations
  if (
    req.method === 'GET' ||
    req.method === 'HEAD' ||
    req.method === 'OPTIONS'
  ) {
    return next();
  }

  // Skip CSRF for development (but log warning)
  if (process.env.NODE_ENV !== 'production') {
    logger.debug('CSRF protection skipped in development');
    return next();
  }

  // Verify CSRF token (double-submit cookie pattern)
  const headerToken = req.headers['x-csrf-token'] as string;
  const cookieToken = req.cookies?.['csrf-token'];

  // Both tokens must be present
  if (!headerToken || !cookieToken) {
    securityLogger.csrfViolation({
      path: req.path,
      method: req.method,
      ip: req.ip,
      hasHeader: !!headerToken,
      hasCookie: !!cookieToken,
    });

    return res.status(403).json({
      success: false,
      error: 'CSRF token missing - possible cross-site request forgery attempt',
    });
  }

  // Tokens must match (constant-time comparison to prevent timing attacks)
  if (headerToken.length !== cookieToken.length) {
    securityLogger.csrfViolation({
      path: req.path,
      method: req.method,
      ip: req.ip,
      hasHeader: true,
      hasCookie: true,
    });

    return res.status(403).json({
      success: false,
      error: 'CSRF token invalid - possible cross-site request forgery attempt',
    });
  }

  if (
    !crypto.timingSafeEqual(Buffer.from(headerToken), Buffer.from(cookieToken))
  ) {
    securityLogger.csrfViolation({
      path: req.path,
      method: req.method,
      ip: req.ip,
      hasHeader: true,
      hasCookie: true,
    });

    return res.status(403).json({
      success: false,
      error: 'CSRF token invalid - possible cross-site request forgery attempt',
    });
  }

  // CSRF validation passed
  next();
}

// Apply to state-changing routes
app.use('/api', csrfProtection);
```

**CSRF Flow**:

```
┌─────────────────────────────────────────────────────────┐
│ 1. Client requests page                                 │
│    GET /api/services                                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 2. Server generates CSRF token                          │
│    - Creates random 32-byte token                       │
│    - Sends in X-CSRF-Token header                       │
│    - Stores in httpOnly cookie                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 3. Client stores token from header                      │
│    - Saves to localStorage or state                     │
│    - Cookie is automatically stored by browser          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 4. Client makes state-changing request                  │
│    POST /api/services                                   │
│    Headers: X-CSRF-Token: <token from step 2>           │
│    Cookies: csrf-token=<same token> (auto-sent)         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 5. Server validates both tokens match                   │
│    - Compares header token to cookie token              │
│    - Uses constant-time comparison (prevent timing)     │
│    - If match → proceed, else → 403 Forbidden           │
└─────────────────────────────────────────────────────────┘
```

**Protection Against**:
- Cross-site request forgery attacks
- Session riding
- One-click attacks

### 7. Error Handling

Sanitizes error messages to prevent information leakage.

```typescript
export function errorHandler(
  err: Error & { status?: number; message?: string; name?: string },
  req: Request,
  res: Response,
  _next: NextFunction
) {
  logger.error('API Error:', err);

  // Don't leak internal error details in production
  const isProd = process.env.NODE_ENV === 'production';

  // Validation errors (safe to expose)
  if (
    err.name === 'ValidationError' ||
    err.message?.includes('Validation failed')
  ) {
    return res.status(400).json({
      success: false,
      error: err.message,
    });
  }

  // Not found errors
  if (err.status === 404 || err.message?.includes('not found')) {
    return res.status(404).json({
      success: false,
      error: 'Resource not found',
    });
  }

  // Unauthorized/Forbidden
  if (err.status === 401 || err.status === 403) {
    return res.status(err.status).json({
      success: false,
      error: err.message || 'Unauthorized',
    });
  }

  // Generic server error (sanitized in production)
  res.status(500).json({
    success: false,
    error: isProd ? 'Internal server error' : err.message,
    ...(isProd ? {} : { stack: err.stack }),
  });
}

// Apply globally (must be last middleware)
app.use(errorHandler);
```

**Error Responses**:

Development:
```json
{
  "success": false,
  "error": "Database connection failed: ECONNREFUSED",
  "stack": "Error: Database connection failed...\n    at ..."
}
```

Production:
```json
{
  "success": false,
  "error": "Internal server error"
}
```

## Security Logger

Dedicated logger for security events with alerting capability.

```typescript
export const securityLogger = {
  csrfViolation: (details: {
    path: string;
    method: string;
    ip?: string;
    hasHeader: boolean;
    hasCookie: boolean;
  }) => {
    logger.error('CSRF_VIOLATION', details);
    // TODO: Send alert to security team
  },

  commandInjectionAttempt: (details: {
    value: string;
    reason: string;
  }) => {
    logger.error('COMMAND_INJECTION_ATTEMPT', details);
    // TODO: Send alert to security team
  },

  rateLimitExceeded: (details: {
    ip: string;
    path: string;
    limit: number;
  }) => {
    logger.warn('RATE_LIMIT_EXCEEDED', details);
  },
};
```

## Performance Characteristics

### Middleware Overhead

| Middleware | Avg Latency | Impact |
|------------|-------------|--------|
| **Helmet** | under 1ms | Negligible |
| **CORS** | under 1ms | Negligible |
| **Rate Limiting** | 1-2ms | Low (in-memory check) |
| **Request ID** | under 1ms | Negligible |
| **Request Size Check** | under 1ms | Negligible |
| **Input Sanitization** | 2-5ms | Low (depends on body size) |
| **CSRF Protection** | 1-2ms | Low (crypto comparison) |
| **Request Logging** | under 1ms | Negligible (async) |
| **Total** | ~5-15ms | Acceptable overhead |

### Memory Usage

```
Rate Limit Store (in-memory):
├─ 100 requests/IP × 1000 IPs = ~100KB
├─ Expires after window (15 min)
└─ Total: <1MB for normal traffic
```

## Design Decisions

### 1. Why Multi-Tier Rate Limiting?

**Decision**: Implement 5 separate rate limiters instead of single global limit.

**Rationale**:
- Different operations have different abuse risks
- Write operations more costly than reads
- Service registration most sensitive (spam prevention)
- MCP connections have different usage patterns
- Fine-grained control over resource usage

**Trade-off**: More complex configuration, higher memory usage.

### 2. Why Double-Submit Cookie for CSRF?

**Decision**: Use double-submit cookie pattern instead of server-side token storage.

**Rationale**:
- Stateless (no server-side session storage)
- Works with load balancers (no sticky sessions)
- Simple implementation (no database lookups)
- Secure (constant-time comparison)

**Trade-off**: Slightly less secure than server-side tokens (vulnerable to subdomain attacks).

### 3. Why Skip CSRF in Development?

**Decision**: Disable CSRF protection in development mode.

**Rationale**:
- Easier local testing (no CSRF token management)
- Faster development iteration
- Production enforces full security
- Logged warning reminds developers

**Trade-off**: Development environment differs from production.

### 4. Why Sanitize in Production?

**Decision**: Hide error stack traces in production.

**Rationale**:
- Prevent information disclosure
- Attackers cannot see internal paths
- Cleaner error messages for end users
- Compliance with security best practices

**Trade-off**: Harder to debug production issues (need log access).

## Future Enhancements

### 1. IP Reputation Scoring

```typescript
async function checkIpReputation(ip: string): Promise<boolean> {
  // Check against threat intelligence feeds
  const reputation = await threatIntelligence.lookup(ip);

  if (reputation.score < 50) {
    securityLogger.suspiciousIp({ ip, score: reputation.score });
    return false;
  }

  return true;
}
```

### 2. Anomaly Detection

```typescript
// Detect unusual request patterns
async function detectAnomaly(req: Request): Promise<void> {
  const pattern = await analyzeRequestPattern(req.ip, req.path, req.method);

  if (pattern.anomalyScore > 0.8) {
    securityLogger.anomalyDetected({
      ip: req.ip,
      path: req.path,
      score: pattern.anomalyScore,
    });

    // Temporarily increase rate limits for this IP
    await temporaryRateLimit(req.ip, 5 * 60 * 1000); // 5 minutes
  }
}
```

### 3. Geographic Restrictions

```typescript
// Block requests from specific countries
const geoBlockList = ['CN', 'RU', 'KP'];  // Example

async function checkGeoRestrictions(req: Request): Promise<void> {
  const country = await geoip.lookup(req.ip);

  if (geoBlockList.includes(country)) {
    securityLogger.geoBlocked({ ip: req.ip, country });
    throw new Error('Access denied from your region');
  }
}
```

### 4. Advanced DDoS Protection

```typescript
// Adaptive rate limiting based on server load
function adaptiveRateLimit(): RateLimitOptions {
  const cpuUsage = os.loadavg()[0];
  const memUsage = process.memoryUsage().heapUsed / process.memoryUsage().heapTotal;

  if (cpuUsage > 0.8 || memUsage > 0.8) {
    // Server under stress - reduce limits
    return { windowMs: 15 * 60 * 1000, max: 50 };
  }

  return { windowMs: 15 * 60 * 1000, max: 100 };
}
```

## Next Steps

- [Master Orchestrator](/docs/architecture/master-orchestrator) - Multi-agent task coordination
- [Payment Routing](/docs/architecture/payment-routing) - Solana payment execution
- [Database Adapters](/docs/architecture/database-adapters) - SQLite/PostgreSQL abstraction
- [SSE Transport](/docs/architecture/sse-transport) - Remote MCP connection management
