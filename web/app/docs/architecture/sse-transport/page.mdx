# SSE Transport Architecture

**TL;DR:** The SSE (Server-Sent Events) Transport enables remote MCP connections over HTTPS, allowing Claude Desktop and other MCP clients to connect to Railway-deployed servers with bidirectional communication: server-pushed updates via SSE stream + client POST messages.

## Overview

The SSETransportManager provides a production-ready transport layer for the Model Context Protocol (MCP) server, enabling remote access via HTTPS while maintaining the same tool interface as local stdio mode.

```
┌──────────────────────────────────────────────────────────┐
│                Claude Desktop (Remote Client)             │
│  - Running on user's machine                             │
│  - Configured with Railway URL                           │
└────────────┬─────────────────────────────────────────────┘
             │
             │ HTTPS over Internet
             │
┌────────────┴─────────────────────────────────────────────┐
│              Railway (Production Server)                  │
│  ┌────────────────────────────────────────────────────┐ │
│  │         API Server (Express.js)                     │ │
│  │  - Handles HTTP requests                           │ │
│  │  - Manages WebSocket connections                   │ │
│  └────────────────────┬───────────────────────────────┘ │
│                       │                                   │
│  ┌────────────────────┴───────────────────────────────┐ │
│  │      SSETransportManager                            │ │
│  │  - GET /mcp/sse (establish SSE stream)             │ │
│  │  - POST /mcp/message?sessionId=X (receive client)  │ │
│  └────────────────────┬───────────────────────────────┘ │
│                       │                                   │
│  ┌────────────────────┴───────────────────────────────┐ │
│  │         MCP Server (stdio mode)                     │ │
│  │  - Same 13 tools as local mode                     │ │
│  │  - Shares ServiceRegistry, Database                │ │
│  └────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────┘
```

<Callout type="info">
**Shared Core**: SSE Transport shares the same ServiceRegistry and Database instances with the REST API - no data duplication!
</Callout>

## Transport Architecture

### Bidirectional Communication

SSE provides server-to-client streaming, but MCP requires bidirectional communication. The solution uses a hybrid approach:

```
┌────────────────────────────────────────────────────────────┐
│                Server → Client (SSE Stream)                 │
│  - Persistent HTTP connection (GET /mcp/sse)               │
│  - Server pushes JSON-RPC messages as SSE events           │
│  - Client receives tool results, errors, notifications     │
└────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│                Client → Server (POST Requests)              │
│  - POST /mcp/message?sessionId=X                           │
│  - Client sends JSON-RPC tool calls                        │
│  - Server processes and responds via SSE stream            │
└────────────────────────────────────────────────────────────┘
```

### Connection Flow

```
Step 1: Establish SSE Stream
─────────────────────────────
Client → Server: GET /mcp/sse
                 Accept: text/event-stream

Server → Client: 200 OK
                 Content-Type: text/event-stream
                 Connection: keep-alive
                 Session-ID: abc123def456...

                 event: session-created
                 data: {"sessionId": "abc123def456..."}


Step 2: Client Sends Tool Call
───────────────────────────────
Client → Server: POST /mcp/message?sessionId=abc123def456
                 Content-Type: application/json

                 {
                   "jsonrpc": "2.0",
                   "method": "tools/call",
                   "params": {
                     "name": "discover_services",
                     "arguments": {
                       "capabilities": ["sentiment-analysis"]
                     }
                   },
                   "id": 1
                 }

Server → Client: 202 Accepted
                 (message queued for processing)


Step 3: Server Pushes Result via SSE
─────────────────────────────────────
Server → Client: (via existing SSE stream)

                 event: message
                 data: {
                   "jsonrpc": "2.0",
                   "result": {
                     "content": [{
                       "type": "text",
                       "text": "Found 3 services..."
                     }]
                   },
                   "id": 1
                 }
```

## SSETransportManager Implementation

### Initialization

```typescript
export class SSETransportManager {
  private mcpServer: Server;                                    // MCP SDK server
  private transports: Map<string, SSEServerTransport> = new Map();  // Active sessions

  constructor(
    private registry: ServiceRegistry,
    private db: Database,
    private solanaVerifier: SolanaVerifier,
    private spendingLimitManager: SpendingLimitManager
  ) {
    // Create MCP server instance (same configuration as server.ts)
    this.mcpServer = new Server(
      {
        name: 'agentmarket-mcp',
        version: '1.0.0',
      },
      {
        capabilities: { tools: {} },
        instructions: `SentientExchange MCP Server - AI Service Marketplace on Solana...`,
      }
    );

    this.setupToolHandlers();
    logger.info('SSE Transport Manager initialized');
  }
}
```

**Shared Components**:
- `registry` - Same ServiceRegistry instance as REST API
- `db` - Same Database instance (SQLite/PostgreSQL)
- `solanaVerifier` - Shared payment verification
- `spendingLimitManager` - Shared budget controls

### Tool Handler Setup

```typescript
private setupToolHandlers(): void {
  // List available tools
  this.mcpServer.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: 'discover_services',
        description: 'Search for AI services by capability, price range, or minimum rating',
        inputSchema: {
          type: 'object',
          properties: {
            capabilities: { type: 'array', items: { type: 'string' } },
            maxPrice: { type: 'string', description: 'Maximum price (e.g., "$0.10")' },
            minRating: { type: 'number', description: 'Minimum rating (1-5)' },
            limit: { type: 'number', default: 10 },
          },
        },
      },
      // ... 12 more tools
    ],
  }));

  // Handle tool calls
  this.mcpServer.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;
    const startTime = Date.now();

    logger.info(`MCP Tool Call: ${name}`, {
      tool: name,
      argsPreview: JSON.stringify(args).substring(0, 200),
      timestamp: new Date().toISOString(),
    });

    try {
      let result: ToolResult;
      switch (name) {
        case 'discover_services':
          result = await discoverServices(this.registry, args as DiscoverServicesArgs);
          break;
        case 'get_service_details':
          result = await getServiceDetails(this.registry, args as GetServiceDetailsArgs);
          break;
        case 'purchase_service':
          result = await purchaseService(this.registry, args as PurchaseServiceArgs, this.spendingLimitManager);
          break;
        // ... handle all 13 tools
      }

      const duration = Date.now() - startTime;
      logger.info(`MCP Tool Success: ${name}`, { tool: name, duration: `${duration}ms` });

      return result;
    } catch (error: unknown) {
      const duration = Date.now() - startTime;
      logger.error(`MCP Tool Error: ${name}`, { tool: name, duration: `${duration}ms`, error: getErrorMessage(error) });

      return {
        content: [{ type: 'text', text: `Error: ${getErrorMessage(error)}` }],
        isError: true,
      };
    }
  });
}
```

**Tool Delegation**:
- Tools use same implementation as stdio mode
- All tools from `src/tools/` directory
- Shared business logic (no code duplication)

### SSE Connection Handler

```typescript
async handleSSEConnection(req: Request, res: Response): Promise<void> {
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  logger.info('SSE connection request', {
    ip: clientIp,
    userAgent: req.headers['user-agent'],
    timestamp: new Date().toISOString(),
  });

  try {
    // Create SSE transport
    const transport = new SSEServerTransport('/mcp/message', res);
    const sessionId = transport.sessionId;

    // Validate session ID format (basic check)
    if (!sessionId || sessionId.length < 16) {
      logger.error('Invalid session ID generated', { sessionId, ip: clientIp });
      if (!res.headersSent) {
        res.status(500).send('Failed to generate valid session');
      }
      return;
    }

    // Store transport with metadata
    this.transports.set(sessionId, transport);

    // Set up close handler
    transport.onclose = () => {
      logger.info('SSE transport closed', {
        sessionId,
        ip: clientIp,
        duration: 'N/A',
      });
      this.transports.delete(sessionId);
    };

    // Connect transport to MCP server
    await this.mcpServer.connect(transport);

    logger.info('SSE stream established', {
      sessionId,
      ip: clientIp,
      activeSessions: this.transports.size,
    });
  } catch (error) {
    logger.error('Error establishing SSE stream', {
      error: error instanceof Error ? getErrorMessage(error) : String(error),
      ip: clientIp,
    });
    if (!res.headersSent) {
      res.status(500).send('Error establishing SSE stream');
    }
  }
}
```

**Security Measures**:
- Session ID validation (length check)
- Client IP logging for monitoring
- Connection timeout (30 minutes inactivity)
- Rate limiting (10 connections per 15 min per IP)

### Message Handler

```typescript
async handleMessage(req: Request, res: Response): Promise<void> {
  const sessionId = req.query.sessionId as string;
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  // Validate session ID presence
  if (!sessionId) {
    logger.error('Missing session ID in message request', {
      ip: clientIp,
      userAgent: req.headers['user-agent'],
    });
    res.status(400).send('Missing sessionId parameter');
    return;
  }

  // Validate session ID format (prevent injection)
  if (!/^[a-zA-Z0-9_-]{16,}$/.test(sessionId)) {
    logger.error('Invalid session ID format', {
      sessionId: sessionId.substring(0, 50),  // Log only first 50 chars
      ip: clientIp,
    });
    res.status(400).send('Invalid sessionId format');
    return;
  }

  // Check if session exists
  const transport = this.transports.get(sessionId);
  if (!transport) {
    logger.error('No active transport found for session', {
      sessionId,
      ip: clientIp,
      activeSessions: this.transports.size,
    });
    res.status(404).send('Session not found');
    return;
  }

  try {
    // handlePostMessage expects (req, res, parsedBody)
    await transport.handlePostMessage(req as unknown as Request, res as unknown as Response, req.body);
  } catch (error) {
    logger.error('Error handling MCP message', {
      sessionId,
      ip: clientIp,
      error: error instanceof Error ? getErrorMessage(error) : String(error),
    });
    if (!res.headersSent) {
      res.status(500).send('Error handling message');
    }
  }
}
```

**Security Measures**:
- Session ID format validation (alphanumeric, dash, underscore only)
- Session existence check
- Rate limiting (60 messages per minute per session)
- Suspicious activity logging

## Session Management

### Session Lifecycle

```
┌─────────────┐
│   Created   │ ← Client connects (GET /mcp/sse)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Active    │ ← Client sends messages (POST /mcp/message)
└──────┬──────┘   Server pushes responses (via SSE)
       │
       ▼
┌─────────────┐
│   Closed    │ ← Client disconnects or timeout
└─────────────┘   Server cleans up session
```

### Session Timeout

```typescript
// Automatic cleanup after 30 minutes of inactivity
const SESSION_TIMEOUT = 30 * 60 * 1000;  // 30 minutes

// Track last activity time
interface SessionMetadata {
  transport: SSEServerTransport;
  lastActivity: number;
  clientIp: string;
}

// Cleanup inactive sessions
setInterval(() => {
  const now = Date.now();
  for (const [sessionId, metadata] of sessions) {
    if (now - metadata.lastActivity > SESSION_TIMEOUT) {
      logger.info('Closing inactive session', { sessionId, inactiveDuration: now - metadata.lastActivity });
      metadata.transport.close();
      sessions.delete(sessionId);
    }
  }
}, 60 * 1000);  // Check every minute
```

### Connection Monitoring

```typescript
getActiveSessionCount(): number {
  return this.transports.size;
}

// Expose via API endpoint
app.get('/api/admin/mcp-stats', async (req, res) => {
  res.json({
    success: true,
    stats: {
      activeSessions: sseTransport.getActiveSessionCount(),
      totalServices: registry.getAllServices().length,
      uptime: process.uptime(),
    },
  });
});
```

## Integration with API Server

The SSE Transport is integrated into the main API server alongside REST endpoints.

### Server Setup

```typescript
// src/api/apiServer.ts

// Initialize shared components
const dbPathOrUrl = process.env.DATABASE_URL || process.env.DATABASE_PATH || './data/agentmarket.db';
const db = new Database(dbPathOrUrl);
await db.initialize();

const registry = new ServiceRegistry(db);
await registry.initialize();

const solanaVerifier = new SolanaVerifier();
const spendingLimitManager = new SpendingLimitManager(db);

// Create SSE Transport Manager
const sseTransport = new SSETransportManager(
  registry,
  db,
  solanaVerifier,
  spendingLimitManager
);

// MCP SSE endpoints
app.get('/mcp/sse', mcpConnectionLimiter, async (req, res) => {
  await sseTransport.handleSSEConnection(req, res);
});

app.post('/mcp/message', mcpMessageLimiter, async (req, res) => {
  await sseTransport.handleMessage(req, res);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  await sseTransport.closeAll();
  await db.close();
  process.exit(0);
});
```

### Endpoint Summary

| Endpoint | Method | Purpose | Rate Limit |
|----------|--------|---------|------------|
| `/mcp/sse` | GET | Establish SSE stream | 10 conn / 15 min |
| `/mcp/message?sessionId=X` | POST | Send client message | 60 msg / min per session |

## Client Configuration

### Claude Desktop Configuration

```json
{
  "mcpServers": {
    "agentmarket-remote": {
      "url": "https://agentmarket.railway.app/mcp",
      "transport": "sse",
      "env": {
        "SOLANA_PRIVATE_KEY": "your-base58-private-key"
      }
    }
  }
}
```

**Note**: Client still manages its own wallet locally. The `SOLANA_PRIVATE_KEY` is used by DirectSolanaProvider on the client's machine, never sent to server.

### API Client Example

```typescript
// Custom MCP client over SSE
class MCPClient {
  private eventSource: EventSource;
  private sessionId: string | null = null;

  async connect(baseUrl: string): Promise<void> {
    // Establish SSE stream
    this.eventSource = new EventSource(`${baseUrl}/mcp/sse`);

    this.eventSource.addEventListener('session-created', (event) => {
      const data = JSON.parse(event.data);
      this.sessionId = data.sessionId;
      console.log('Session created:', this.sessionId);
    });

    this.eventSource.addEventListener('message', (event) => {
      const message = JSON.parse(event.data);
      console.log('Received:', message);
      // Handle tool result
    });

    this.eventSource.onerror = (error) => {
      console.error('SSE error:', error);
    };
  }

  async callTool(name: string, args: unknown): Promise<void> {
    if (!this.sessionId) {
      throw new Error('Not connected');
    }

    const response = await fetch(`${baseUrl}/mcp/message?sessionId=${this.sessionId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'tools/call',
        params: { name, arguments: args },
        id: Date.now(),
      }),
    });

    if (!response.ok) {
      throw new Error(`Tool call failed: ${response.statusText}`);
    }

    // Result will arrive via SSE stream
  }

  disconnect(): void {
    this.eventSource?.close();
  }
}

// Usage
const client = new MCPClient();
await client.connect('https://agentmarket.railway.app');
await client.callTool('discover_services', { capabilities: ['sentiment-analysis'] });
```

## Performance Characteristics

### Connection Overhead

| Metric | Value | Notes |
|--------|-------|-------|
| **Initial Connection** | 100-300ms | SSE stream setup |
| **Message Latency** | 50-150ms | POST + SSE push |
| **Heartbeat Interval** | 30s | Keep connection alive |
| **Max Concurrent Sessions** | 500 | Limited by server resources |

### Bandwidth Usage

```
SSE Connection:
├─ Initial handshake: ~500 bytes
├─ Heartbeat (every 30s): ~50 bytes
├─ Message overhead: ~200 bytes per message
└─ Total for 60 min session: ~4KB (heartbeats only)

Typical Tool Call:
├─ Request (POST): 500-2000 bytes
├─ Response (SSE): 1000-10000 bytes
└─ Total: ~1.5-12 KB per call
```

### Comparison: stdio vs SSE

| Metric | stdio (Local) | SSE (Remote) |
|--------|---------------|--------------|
| **Latency** | under 1ms | 50-150ms |
| **Setup Time** | Instant | 100-300ms |
| **Reliability** | 100% | 99.9% (network dependent) |
| **Scalability** | Single user | Multi-user |
| **Network Dependency** | None | Required |
| **Deployment** | Local only | Cloud-ready |

## Design Decisions

### 1. Why SSE Instead of WebSocket?

**Decision**: Use Server-Sent Events (SSE) + POST for bidirectional communication instead of WebSocket.

**Rationale**:
- **MCP SDK Support**: @modelcontextprotocol/sdk provides SSEServerTransport out-of-box
- **Simplicity**: SSE is simpler than WebSocket (standard HTTP, no protocol upgrade)
- **Compatibility**: Works through proxies and firewalls (standard HTTP)
- **Reconnection**: Browsers automatically reconnect dropped SSE connections
- **Debugging**: Easy to inspect with browser DevTools (Network tab)

**Trade-off**: Slightly higher latency than WebSocket (POST + SSE vs single connection).

### 2. Why Shared Components?

**Decision**: Share ServiceRegistry, Database, and payment components between SSE Transport and REST API.

**Rationale**:
- **No Data Duplication**: Single source of truth for services
- **Consistency**: REST and MCP see same data
- **Memory Efficiency**: One in-memory cache instead of two
- **Simplified Maintenance**: Update one codebase, both transports benefit

**Trade-off**: Increased coupling between transport layers.

### 3. Why Session ID Validation?

**Decision**: Validate session ID format with regex before using.

**Rationale**:
- **Injection Prevention**: Prevent SQL/NoSQL injection via session ID
- **DoS Prevention**: Reject obviously invalid IDs early
- **Logging Safety**: Prevent log injection attacks
- **Security Audit**: Track suspicious session ID patterns

**Trade-off**: Small overhead for regex matching (~0.1ms).

### 4. Why 30-Minute Timeout?

**Decision**: Close inactive sessions after 30 minutes.

**Rationale**:
- **Resource Cleanup**: Free memory from abandoned sessions
- **Security**: Reduce attack surface from stale sessions
- **User Experience**: Long enough for typical usage patterns
- **Server Cost**: Reduce Railway usage costs (idle connections)

**Trade-off**: Users must reconnect after timeout.

## Security Measures

### 1. Rate Limiting

```typescript
// MCP connection limit
export const mcpConnectionLimiter = rateLimitMiddleware({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 10,                    // Max 10 new SSE connections per 15 min per IP
});

// MCP message limit
export const mcpMessageLimiter = rateLimitMiddleware({
  windowMs: 1 * 60 * 1000,   // 1 minute
  max: 60,                    // Max 60 messages per minute (1 per second avg)
  keyGenerator: (req) => {
    const sessionId = req.query.sessionId as string;
    return sessionId || (req.ip as string) || 'unknown';
  },
});
```

### 2. Session ID Validation

```typescript
// Only allow alphanumeric, dash, underscore
if (!/^[a-zA-Z0-9_-]{16,}$/.test(sessionId)) {
  logger.error('Invalid session ID format', { sessionId: sessionId.substring(0, 50), ip: clientIp });
  res.status(400).send('Invalid sessionId format');
  return;
}
```

### 3. Client IP Logging

```typescript
// Track all connection attempts
logger.info('SSE connection request', {
  ip: clientIp,
  userAgent: req.headers['user-agent'],
  timestamp: new Date().toISOString(),
});

// Log suspicious activity
logger.error('No active transport found for session', {
  sessionId,
  ip: clientIp,
  activeSessions: this.transports.size,
});
```

### 4. Graceful Shutdown

```typescript
async closeAll(): Promise<void> {
  logger.info(`Closing ${this.transports.size} active SSE transports...`);
  for (const transport of this.transports.values()) {
    try {
      await transport.close();
    } catch (error) {
      logger.error('Error closing transport:', error);
    }
  }
  this.transports.clear();
  logger.info('All SSE transports closed');
}

// Register signal handlers
process.on('SIGTERM', async () => {
  await sseTransport.closeAll();
  process.exit(0);
});
```

## Debugging SSE Connections

### Browser DevTools

1. Open Network tab
2. Filter by `EventStream` type
3. Inspect SSE messages in real-time
4. Check connection status and errors

### Server Logs

```bash
# Watch SSE connection logs
tail -f logs/app.log | grep 'SSE'

# Output:
SSE connection request { ip: '192.168.1.100', userAgent: 'Mozilla/5.0 ...' }
SSE stream established { sessionId: 'abc123...', ip: '192.168.1.100', activeSessions: 1 }
MCP Tool Call: discover_services { tool: 'discover_services', argsPreview: '{"capabilities":["sentiment"]}' }
MCP Tool Success: discover_services { tool: 'discover_services', duration: '45ms' }
SSE transport closed { sessionId: 'abc123...', ip: '192.168.1.100' }
```

### cURL Testing

```bash
# Establish SSE stream
curl -N -H "Accept: text/event-stream" https://agentmarket.railway.app/mcp/sse

# Output:
event: session-created
data: {"sessionId":"abc123def456..."}

event: heartbeat
data: {"timestamp":1704994800}

# Send message (in another terminal)
curl -X POST https://agentmarket.railway.app/mcp/message?sessionId=abc123def456 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "discover_services",
      "arguments": {"capabilities": ["sentiment-analysis"]}
    },
    "id": 1
  }'
```

## Future Enhancements

### 1. Compression

```typescript
// Enable SSE compression
app.use(compression({
  filter: (req, res) => {
    // Compress SSE streams
    if (req.path === '/mcp/sse') return true;
    return compression.filter(req, res);
  },
}));
```

### 2. Connection Pooling

```typescript
// Reuse connections for same user
class ConnectionPool {
  private pools: Map<string, SSEServerTransport[]> = new Map();

  acquire(userId: string): SSEServerTransport {
    const pool = this.pools.get(userId) || [];
    return pool.pop() || createNewTransport();
  }

  release(userId: string, transport: SSEServerTransport): void {
    const pool = this.pools.get(userId) || [];
    pool.push(transport);
    this.pools.set(userId, pool);
  }
}
```

### 3. Binary Message Support

```typescript
// Send binary data via base64 in SSE
event: binary-message
data: {"encoding":"base64","content":"SGVsbG8gV29ybGQ="}
```

### 4. Message Queue

```typescript
// Queue messages during reconnection
class MessageQueue {
  private queues: Map<string, unknown[]> = new Map();

  enqueue(sessionId: string, message: unknown): void {
    const queue = this.queues.get(sessionId) || [];
    queue.push(message);
    this.queues.set(sessionId, queue);
  }

  flush(sessionId: string, transport: SSEServerTransport): void {
    const queue = this.queues.get(sessionId) || [];
    queue.forEach(msg => transport.send(msg));
    this.queues.delete(sessionId);
  }
}
```

## Next Steps

- [Master Orchestrator](/docs/architecture/master-orchestrator) - Multi-agent task coordination
- [Payment Routing](/docs/architecture/payment-routing) - Solana payment execution
- [Database Adapters](/docs/architecture/database-adapters) - SQLite/PostgreSQL abstraction
- [Security Middleware](/docs/architecture/security-middleware) - Rate limiting and input validation
