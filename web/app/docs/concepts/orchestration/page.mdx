# Multi-Service Orchestration

**TL;DR:** The Master Orchestrator enables AI agents to tackle complex tasks by decomposing them into subtasks, discovering relevant services, spawning specialist agents, and coordinating multi-service workflows autonomously.

## What is Orchestration?

Orchestration is the process of **coordinating multiple AI services** to accomplish complex tasks that no single service can handle alone.

Think of it like:
- **Project Manager** - Breaks down big tasks into manageable pieces
- **Resource Allocator** - Finds the right services for each subtask
- **Traffic Controller** - Coordinates data flow between services
- **Cost Tracker** - Monitors spending across all operations

## The Master Orchestrator

AgentMarket's **MasterOrchestrator** is an autonomous agent that:

1. âœ… **Decomposes** complex requests into subtasks
2. âœ… **Discovers** relevant services from the marketplace
3. âœ… **Spawns** specialist agents for each subtask
4. âœ… **Executes** parallel workflows with dependency resolution
5. âœ… **Aggregates** results into final output
6. âœ… **Tracks** costs and generates detailed timelines

**Example Request**: *"Create a complete investor pitch deck for a SaaS startup"*

**Orchestration Result**:
- 7 specialist agents spawned
- 15+ services discovered and evaluated
- 12 services hired and paid
- $2.47 total cost
- Complete pitch deck delivered in 45 seconds

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Master Orchestrator Agent                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  1. Task Decomposition Engine              â”‚     â”‚
â”‚  â”‚     "Pitch Deck" â†’ 7 subtasks             â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                   â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  2. Service Discovery                      â”‚     â”‚
â”‚  â”‚     Query ServiceRegistry for capabilities â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                   â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  3. Agent Spawner                          â”‚     â”‚
â”‚  â”‚     Create specialist agents:              â”‚     â”‚
â”‚  â”‚     â€¢ Research Agent                       â”‚     â”‚
â”‚  â”‚     â€¢ Analysis Agent                       â”‚     â”‚
â”‚  â”‚     â€¢ Strategy Agent                       â”‚     â”‚
â”‚  â”‚     â€¢ Creative Agent                       â”‚     â”‚
â”‚  â”‚     â€¢ Data Viz Agent                       â”‚     â”‚
â”‚  â”‚     â€¢ Copywriting Agent                    â”‚     â”‚
â”‚  â”‚     â€¢ Aggregation Agent                    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                   â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  4. Execution Coordinator                  â”‚     â”‚
â”‚  â”‚     â€¢ Parallel execution                   â”‚     â”‚
â”‚  â”‚     â€¢ Dependency resolution                â”‚     â”‚
â”‚  â”‚     â€¢ Payment handling                     â”‚     â”‚
â”‚  â”‚     â€¢ Error recovery                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                   â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  5. Result Aggregator                      â”‚     â”‚
â”‚  â”‚     Combine outputs â†’ Final deliverable    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Orchestration Flow

### Example: Pitch Deck Generation

**User Request**: *"Generate a complete investor pitch deck for an AI coding assistant startup"*

#### Step 1: Task Decomposition

```typescript
const subtasks = [
  { id: 'research-1', description: 'Research target market and competitors' },
  { id: 'analysis-1', description: 'Analyze market size and growth trends' },
  { id: 'analysis-2', description: 'Generate pricing strategy' },
  { id: 'strategy-1', description: 'Develop go-to-market strategy' },
  { id: 'creative-1', description: 'Write compelling marketing copy' },
  { id: 'creative-2', description: 'Generate data visualizations' },
  { id: 'final-1', description: 'Build complete pitch deck presentation' }
];
```

**Output**: 7 subtasks identified

#### Step 2: Service Discovery

```typescript
const availableServices = await registry.getAllServices();
// Returns: 20+ services (sentiment, image, data aggregation, etc.)

// Match services to subtask requirements
for (const subtask of subtasks) {
  const matchedServices = availableServices.filter(service =>
    service.capabilities.some(cap =>
      subtask.description.toLowerCase().includes(cap.split('-')[0])
    )
  );
}
```

**Output**: 15 relevant services discovered

#### Step 3: Agent Spawning

```typescript
const specialists = [
  {
    id: 'agent-research-001',
    name: 'Research Specialist',
    role: 'Market Research',
    capabilities: ['data-aggregation', 'web-scraping', 'sentiment-analysis'],
    tasks: ['research-1'],
    servicesHired: []
  },
  {
    id: 'agent-analysis-001',
    name: 'Analysis Specialist',
    role: 'Data Analysis',
    capabilities: ['data-analysis', 'trend-detection'],
    tasks: ['analysis-1', 'analysis-2'],
    servicesHired: []
  },
  // ... 5 more specialist agents
];
```

**Output**: 7 specialist agents spawned

#### Step 4: Parallel Execution

```typescript
// Execute tasks in parallel where possible
await Promise.all([
  researchAgent.execute(services),    // Independent
  analysisAgent.execute(services),     // Independent
  strategyAgent.execute(services),     // Independent
]);

// Sequential execution for dependent tasks
const copywritingResult = await copyAgent.execute(services, {
  dependsOn: [researchResult, analysisResult]
});

const visualizationResult = await vizAgent.execute(services, {
  dependsOn: [analysisResult]
});

const finalDeck = await aggregationAgent.execute(services, {
  dependsOn: [copywritingResult, visualizationResult, strategyResult]
});
```

**Timeline**:
```
0.0s  â†’ [Research Agent] Started
0.1s  â†’ [Analysis Agent] Started
0.2s  â†’ [Strategy Agent] Started
2.3s  â†’ [Research Agent] Hired Data Aggregator ($0.25)
3.1s  â†’ [Analysis Agent] Hired Trend Analyzer ($0.15)
5.7s  â†’ [Research Agent] Completed
6.2s  â†’ [Analysis Agent] Completed
7.8s  â†’ [Copywriting Agent] Started (depends on Research + Analysis)
8.9s  â†’ [Copywriting Agent] Hired Text Generator ($0.50)
12.4s â†’ [Visualization Agent] Started (depends on Analysis)
13.2s â†’ [Visualization Agent] Hired Chart Generator ($0.35)
18.7s â†’ [Aggregation Agent] Started (depends on all)
19.3s â†’ [Aggregation Agent] Hired Document Builder ($0.75)
23.1s â†’ [Master Orchestrator] Completed
```

**Output**: Final pitch deck with 12 slides

#### Step 5: Result Aggregation

```typescript
const finalOutput = {
  pitchDeck: {
    slides: [
      { title: 'Problem', content: '...' },
      { title: 'Solution', content: '...' },
      { title: 'Market Size', content: '...', chart: '...' },
      { title: 'Business Model', content: '...' },
      // ... 8 more slides
    ]
  },
  metadata: {
    totalTime: 23100,         // ms
    totalCost: 2.47,          // USD
    servicesUsed: 12,
    agentsSpawned: 7,
    tasksCompleted: 7
  }
};
```

## Code Implementation

**src/orchestrator/MasterOrchestrator.ts** (Lines 61-139)

```typescript
export class MasterOrchestrator {
  private registry: ServiceRegistry;
  private agents: Map<string, SpecialistAgent> = new Map();
  private timeline: Array<TimelineEvent> = [];

  async executeComplexTask(userRequest: string): Promise<OrchestrationResult> {
    const startTime = Date.now();

    // 1. Decompose task
    const subtasks = await this.decomposeTask(userRequest);
    logger.info(`ğŸ“‹ Decomposed into ${subtasks.length} subtasks`);

    // 2. Discover services
    const services = this.registry.getAllServices();
    logger.info(`ğŸ” Discovered ${services.length} services`);

    // 3. Spawn agents
    const specialists = await this.spawnSpecialistAgents(subtasks, services);
    logger.info(`ğŸ¤– Spawned ${specialists.length} specialist agents`);

    // 4. Execute subtasks
    const results = await this.executeSubtasks(specialists, subtasks, services);

    // 5. Aggregate results
    const finalOutput = await this.aggregateResults(results, userRequest);

    return {
      success: true,
      finalOutput,
      metadata: {
        totalTime: Date.now() - startTime,
        totalCost: this.totalCost,
        servicesUsed: this.countServicesUsed(),
        agentsSpawned: this.agents.size,
        tasksCompleted: subtasks.length
      },
      agents: Array.from(this.agents.values()),
      timeline: this.timeline
    };
  }
}
```

## Specialist Agent Types

| Agent Type | Role | Capabilities | Example Services |
|------------|------|--------------|------------------|
| **Research Agent** | Gather data | web-scraping, data-aggregation | Market research APIs |
| **Analysis Agent** | Extract insights | data-analysis, trend-detection | Statistical analysis tools |
| **Strategy Agent** | Planning | business-strategy, optimization | Strategy consulting APIs |
| **Creative Agent** | Content creation | text-generation, copywriting | GPT-based writing services |
| **Data Viz Agent** | Visualization | chart-generation, infographics | Data visualization APIs |
| **Aggregation Agent** | Combine results | document-assembly, formatting | Document builders |

## Dependency Resolution

The orchestrator handles task dependencies automatically:

```typescript
interface Task {
  id: string;
  description: string;
  status: 'pending' | 'in-progress' | 'completed';
  dependsOn?: string[];  // IDs of prerequisite tasks
  result?: any;
}

async executeSubtasks(agents: SpecialistAgent[], tasks: Task[]): Promise<any[]> {
  const completed = new Set<string>();
  const results: any[] = [];

  while (completed.size < tasks.length) {
    // Find tasks whose dependencies are met
    const ready = tasks.filter(task =>
      task.status === 'pending' &&
      (!task.dependsOn || task.dependsOn.every(depId => completed.has(depId)))
    );

    if (ready.length === 0) {
      throw new Error('Circular dependency detected!');
    }

    // Execute ready tasks in parallel
    const batchResults = await Promise.all(
      ready.map(task => this.executeTask(task, agents))
    );

    // Mark as completed
    ready.forEach((task, i) => {
      task.status = 'completed';
      task.result = batchResults[i];
      completed.add(task.id);
      results.push(batchResults[i]);
    });
  }

  return results;
}
```

**Example Dependency Graph**:
```
research-1 (no deps) â”€â”€â”€â”€â”€â”
                          â”œâ”€â”€â†’ copywriting-1
analysis-1 (no deps) â”€â”€â”€â”€â”€â”˜       â”‚
                                  â”‚
analysis-2 (no deps) â”€â”€â”€â”€â”€â”€â†’ viz-1â”‚
                                  â”‚
strategy-1 (no deps) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                                  â”œâ”€â”€â†’ final-1
creative-1 (no deps) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Cost Tracking

Every service call is tracked:

```typescript
async hireService(agent: SpecialistAgent, service: Service, input: any): Promise<any> {
  const startTime = Date.now();

  // 1. Execute payment
  const paymentResult = await this.executePayment(service);
  this.totalCost += parseFloat(service.pricing.perRequest);

  // 2. Call service
  const result = await this.callService(service, input, paymentResult.signature);

  // 3. Log to timeline
  this.timeline.push({
    timestamp: Date.now() - this.startTime,
    event: 'service-hired',
    agent: agent.id,
    service: service.name,
    cost: parseFloat(service.pricing.perRequest)
  });

  // 4. Update agent stats
  agent.servicesHired.push(service.id);
  agent.totalCost += parseFloat(service.pricing.perRequest);

  return result;
}
```

**Cost Breakdown**:
```
Research Agent:
  - Data Aggregator: $0.25
  - Sentiment Analyzer: $0.10
  Subtotal: $0.35

Analysis Agent:
  - Trend Analyzer: $0.15
  - Statistical Analyzer: $0.20
  Subtotal: $0.35

Copywriting Agent:
  - Text Generator: $0.50
  Subtotal: $0.50

Visualization Agent:
  - Chart Generator: $0.35
  Subtotal: $0.35

Aggregation Agent:
  - Document Builder: $0.75
  Subtotal: $0.75

TOTAL: $2.47
```

## Error Handling & Retry Logic

```typescript
async executeTask(task: Task, agents: SpecialistAgent[]): Promise<any> {
  const agent = agents.find(a => a.tasks.includes(task.id));
  const maxRetries = 3;
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Find best service for task
      const service = await this.findBestService(task, agent);

      if (!service) {
        throw new Error(`No suitable service found for: ${task.description}`);
      }

      // Execute with service
      const result = await this.hireService(agent, service, task);

      logger.info(`âœ… Task completed: ${task.id} (attempt ${attempt})`);
      return result;

    } catch (error) {
      lastError = error;
      logger.warn(`âš ï¸ Task failed: ${task.id} (attempt ${attempt}/${maxRetries})`);

      if (attempt < maxRetries) {
        // Try backup service
        await this.sleep(1000 * attempt);  // Exponential backoff
      }
    }
  }

  throw new Error(`Task failed after ${maxRetries} attempts: ${lastError.message}`);
}
```

## Real-Time Updates

Orchestration progress is broadcast via WebSocket:

```typescript
io.emit('orchestration-update', {
  type: 'agent-spawned',
  agent: agent.id,
  timestamp: Date.now()
});

io.emit('orchestration-update', {
  type: 'service-hired',
  agent: agent.id,
  service: service.id,
  cost: service.pricing.perRequest,
  timestamp: Date.now()
});

io.emit('orchestration-update', {
  type: 'task-completed',
  task: task.id,
  result: result,
  timestamp: Date.now()
});
```

Clients can subscribe:
```typescript
socket.on('orchestration-update', (update) => {
  console.log(`[${update.type}] ${update.agent || ''} ${update.service || ''}`);
  updateVisualization(update);
});
```

## Performance Characteristics

| Metric | Value | Notes |
|--------|-------|-------|
| **Task Decomposition** | ~100-500ms | Depends on complexity |
| **Service Discovery** | ~1-5ms | In-memory cache |
| **Agent Spawning** | ~10-50ms | Object creation |
| **Parallel Execution** | Limited by slowest service | Network I/O bound |
| **Result Aggregation** | ~50-200ms | Data merging |

**Bottleneck**: Service API calls (1-10 seconds each)

**Optimization**: Parallel execution reduces total time by 60-80%

## Use Cases

### 1. Content Generation Pipeline

**Request**: *"Create a blog post with images and social media snippets"*

**Agents**:
- Topic Research Agent â†’ Data aggregation service
- Content Writer Agent â†’ Text generation service
- Image Generator Agent â†’ DALL-E API service
- SEO Optimizer Agent â†’ SEO analysis service
- Social Media Agent â†’ Snippet generation service

**Result**: Complete blog post package in 30 seconds

### 2. Business Intelligence Dashboard

**Request**: *"Analyze our Q4 sales data and create executive dashboard"*

**Agents**:
- Data Collector Agent â†’ Database integration service
- Statistical Analyst Agent â†’ Analytics service
- Trend Detector Agent â†’ ML prediction service
- Visualization Agent â†’ Charting service
- Report Writer Agent â†’ Document assembly service

**Result**: Interactive dashboard with insights

### 3. Competitive Analysis Report

**Request**: *"Analyze top 5 competitors in the SaaS CRM space"*

**Agents**:
- Web Scraper Agent â†’ Scraping service
- Sentiment Analyzer Agent â†’ NLP service
- Feature Comparator Agent â†’ Comparison service
- Pricing Analyst Agent â†’ Price tracking service
- Report Generator Agent â†’ PDF generation service

**Result**: 20-page competitive analysis PDF

## Best Practices

### 1. Design for Parallelism

```typescript
// Good: Independent tasks run in parallel
await Promise.all([
  agent1.execute(),
  agent2.execute(),
  agent3.execute()
]);

// Bad: Unnecessary sequential execution
await agent1.execute();
await agent2.execute();
await agent3.execute();
```

### 2. Minimize Dependencies

```typescript
// Good: Only necessary dependencies
{
  id: 'final-report',
  dependsOn: ['analysis-1', 'analysis-2']  // Only needs analysis results
}

// Bad: Over-specified dependencies
{
  id: 'final-report',
  dependsOn: ['research-1', 'research-2', 'analysis-1', 'analysis-2', 'viz-1']
}
```

### 3. Set Budget Limits

```typescript
const orchestrator = new MasterOrchestrator(registry);
orchestrator.setMaxCost(5.00);  // Don't exceed $5

const result = await orchestrator.executeComplexTask(request);
// Throws error if cost > $5
```

### 4. Handle Partial Failures Gracefully

```typescript
// Continue even if non-critical tasks fail
const results = await Promise.allSettled([
  criticalTask1.execute(),
  criticalTask2.execute(),
  optionalTask.execute()  // Failure here shouldn't block others
]);

const finalOutput = aggregateResults(
  results.filter(r => r.status === 'fulfilled')
);
```

## Visualization

The web dashboard shows orchestration in real-time:

**3D Particle View**:
- Each agent = colored particle
- Service calls = connections between particles
- Cost = particle size
- Activity = particle glow intensity

**Timeline View**:
```
0.0s  â–ˆâ–ˆâ–ˆâ–ˆ Research Agent spawned
0.1s  â–ˆâ–ˆâ–ˆâ–ˆ Analysis Agent spawned
2.3s  â”€â”€â”€â”€ Research hired Data Aggregator ($0.25)
5.7s  â–ˆâ–ˆâ–ˆâ–ˆ Research completed
8.9s  â”€â”€â”€â”€ Copywriting hired Text Generator ($0.50)
...
```

## Next Steps

- [Master Orchestrator Architecture](/docs/architecture/master-orchestrator) - Deep dive into internals
- [Smart Workflows](/docs/guides/smart-workflows) - Optimize multi-service calls
- [Spending Limits](/docs/guides/spending-limits) - Budget controls for orchestration
- [WebSocket API](/docs/guides/websocket) - Real-time orchestration updates
